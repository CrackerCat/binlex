#!/usr/bin/env python

import os
import sys
import configparser
import argparse
import time
import json
import logging
import pybinlex
from hashlib import sha256
from libblapi.minio import MinIOHandler
from libblapi.amqp import AMQPHandler

logger = logging.getLogger(__name__)

__author__  = 'c3r3b3ru5'
__version__ = '1.1.1'

class BLDEC():

    """
    A Binlex Decompile Worker
    """

    def decompile_raw(self, data, architecture, corpus):
        decompiler = pybinlex.Decompiler()
        if architecture == 'x86':
            decompiler.setup(pybinlex.cs_arch.CS_ARCH_X86, pybinlex.cs_mode.CS_MODE_32, 0)
        if architecture == 'x86_64':
            decompiler.setup(pybinlex.cs_arch.CS_ARCH_X86, pybinlex.cs_mode.CS_MODE_64, 0)
        decompiler.set_threads(
            self.config['bldec'].getint('threads'),
            self.config['bldec'].getint('thread_cycles'),
            self.config['bldec'].getint('thread_sleep'),
            0)
        decompiler.set_mode("raw:x86", 0)
        decompiler.set_file_sha256(sha256(data).hexdigest(), 0)
        decompiler.set_corpus(corpus, 0)
        decompiler.decompile(data, 0, 0)
        traits = decompiler.get_traits()
        return traits

    def decompile_pe(self, data, architecture, corpus):
        file_hash = sha256(data).hexdigest()
        pe = pybinlex.PE()
        decompiler = pybinlex.Decompiler()
        if architecture == 'x86':
            pe.setup(pybinlex.MACHINE_TYPES.IMAGE_FILE_MACHINE_I386)
        if architecture == 'x86_64':
            pe.setup(pybinlex.MACHINE_TYPES.IMAGE_FILE_MACHINE_AMD64)
        pe.read_buffer(data)
        sections = pe.get_sections()
        for i in range(0, len(sections)):
            if architecture == 'x86':
                decompiler.setup(pybinlex.cs_arch.CS_ARCH_X86, pybinlex.cs_mode.CS_MODE_32, i)
                decompiler.set_mode("pe:x86", i)
            if architecture == 'x86_64':
                decompiler.setup(pybinlex.cs_arch.CS_ARCH_X86, pybinlex.cs_mode.CS_MODE_64, i)
                decompiler.set_mode("pe:x86_64", i)
            decompiler.set_threads(
                self.config['bldec'].getint('threads'),
                self.config['bldec'].getint('thread_cycles'),
                self.config['bldec'].getint('thread_sleep'),
                i)
            decompiler.set_corpus(corpus, i)
            decompiler.set_file_sha256(file_hash, i)
            decompiler.decompile(sections[i]['data'], sections[i]['offset'], i)
        traits = decompiler.get_traits()
        return traits

    def decompile_elf(self, data, architecture, corpus):
        file_hash = sha256(data).hexdigest()
        elf = pybinlex.ELF()
        decompiler = pybinlex.Decompiler()
        if architecture == 'x86':
            elf.setup(pybinlex.ARCH.EM_386)
        if architecture == 'x86_64':
            elf.setup(pybinlex.ARCH.EM_X86_64)
        result = elf.read_buffer(data)
        if result is False:
            return result
        sections = elf.get_sections()
        for i in range(0, len(sections)):
            if architecture == 'x86':
                decompiler.setup(pybinlex.cs_arch.CS_ARCH_X86, pybinlex.cs_mode.CS_MODE_32, i)
                decompiler.set_mode("elf:x86", i)
            if architecture == 'x86_64':
                decompiler.setup(pybinlex.cs_arch.CS_ARCH_X86, pybinlex.cs_mode.CS_MODE_64, i)
                decompiler.set_mode("elf:x86_64", i)
            decompiler.set_corpus(corpus, i)
            decompiler.set_file_sha256(file_hash, i)
            decompiler.set_threads(
                self.config['bldec'].getint('threads'),
                self.config['bldec'].getint('thread_cycles'),
                self.config['bldec'].getint('thread_sleep'),
                i)
            decompiler.decompile(sections[i]['data'], sections[i]['offset'], i)
        traits = decompiler.get_traits()
        return traits

    def arguments(self):
        parser = argparse.ArgumentParser(
            prog=f'bldec v{__version__}',
            description="A Binlex Decompile Worker",
            epilog=f'Author: {__author__}'
        )
        parser.add_argument(
            '--version',
            action='version',
            version=f'v{__version__}'
        )
        parser.add_argument(
            '-c',
            '--config',
            default=None,
            required=True,
            help='Configuration File'
        )
        args = parser.parse_args()
        self.config = configparser.ConfigParser()
        self.config.read(args.config)
        self.minio = MinIOHandler(self.config)
        self.amqp = AMQPHandler(self.config)

    def process(self, ch, method, properties, body):
        try:
            data = json.loads(body)
            file_type = data['mode'].split(':')[0]
            binary_data = self.minio.download(
                bucket_name=data['corpus'],
                object_name=data['object_name'])
            if file_type == 'pe':
                traits = self.decompile_pe(
                    binary_data,
                    data['mode'].split(':')[1],
                    data['corpus'])
            elif file_type == 'elf':
                traits = self.decompile_elf(
                    binary_data,
                    data['mode'].split(':')[1],
                    data['corpus'])
            elif file_type == 'raw':
                traits = self.decompile_raw(
                    binary_data,
                    data['mode'].split(':')[1],
                    data['corpus'])
            else:
                raise Exception('unknown file format')
            for trait in traits:
                self.amqp.publish(
                    self.config['amqp'].get('traits_queue'),
                    json.dumps(trait))
            self.minio.delete(
                bucket_name=self.config['amqp'].get('decomp_queue'),
                object_name=data['object_name'])
        except Exception as e:
            exc_type, exc_obj, exc_tb = sys.exc_info()
            fname = os.path.split(exc_tb.tb_frame.f_code.co_filename)[1]
            logger.error(exc_type, fname, exc_tb.tb_lineno)
        ch.basic_ack(method.delivery_tag)

    def main(self):
        self.arguments()
        self.amqp.consume(
            self.config['amqp'].get('decomp_queue'),
            self.process)

if __name__ in '__main__':
    try:
        bldec = BLDEC()
        bldec.main()
    except KeyboardInterrupt:
        print('keyboard interrupt, exiting...')
